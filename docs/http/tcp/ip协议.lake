<!doctype lake><meta name="doc-version" content="1" /><meta name="viewport" content="adapt" /><h3 data-lake-id="fOaOZ" id="fOaOZ"><span data-lake-id="u80f45be2" id="u80f45be2">分层</span></h3><p data-lake-id="u43e856d8" id="u43e856d8"><span data-lake-id="uabd437f2" id="uabd437f2">应用层：http</span></p><p data-lake-id="u7c6a3430" id="u7c6a3430"><span data-lake-id="ueba820a7" id="ueba820a7">传输层：tcp  端对端</span></p><p data-lake-id="u186b245b" id="u186b245b"><span data-lake-id="u3f949d17" id="u3f949d17">数据层：ip 点对点</span></p><p data-lake-id="u6d243dff" id="u6d243dff"><span data-lake-id="u3bc63df9" id="u3bc63df9">链路层：网络接口</span></p><h3 data-lake-id="yvSFL" id="yvSFL"><span data-lake-id="ubb643ded" id="ubb643ded">tcp三次握手</span></h3><p data-lake-id="ufd8b617a" id="ufd8b617a"><a href="https://juejin.cn/post/6844903834708344840" target="_blank" data-lake-id="uf28fd504" id="uf28fd504"><span data-lake-id="ue70c8847" id="ue70c8847">关于三次握手与四次挥手面试官想考我们什么？--- 不看后悔系列</span></a></p><p data-lake-id="u2db30431" id="u2db30431"><span data-lake-id="ua262d0fc" id="ua262d0fc">&amp;#x20;流程：&amp;#x20;</span></p><p data-lake-id="u8545b3a6" id="u8545b3a6"><span data-lake-id="u04500f04" id="u04500f04">流程的文字描述：&amp;#x20;</span></p><p data-lake-id="u39799873" id="u39799873"><span data-lake-id="ua679c96d" id="ua679c96d">0： 刚开始客户端处于closed，服务端处于listen&amp;#x20;</span></p><p data-lake-id="ued7b7b81" id="ued7b7b81"><span data-lake-id="u165cd325" id="u165cd325">1：一次握手 &amp;#x9;</span></p><p data-lake-id="u85988660" id="u85988660"><span data-lake-id="u3847f648" id="u3847f648">&amp;#x9;a.客户端初始化他的序列号sn，通过报文SYN发给服务端。 &amp;#x9;</span></p><p data-lake-id="u9d8f7f8d" id="u9d8f7f8d"><span data-lake-id="ubc9be7e5" id="ubc9be7e5">&amp;#x9;b.这时候客户端处于SYN</span><span data-lake-id="uecf04e2a" id="uecf04e2a">_</span><span data-lake-id="u700ee829" id="u700ee829">send状态&amp;#x20;</span></p><p data-lake-id="uc6bd8694" id="uc6bd8694"><span data-lake-id="u206a770b" id="u206a770b">2：第二次握手 &amp;#x9;</span></p><p data-lake-id="ub6ffcf67" id="ub6ffcf67"><span data-lake-id="u010201b2" id="u010201b2">&amp;#x9;a.服务端收到SYN报文之后，初始化他的序列号sn通过SYN发送给客户端。 &amp;#x9;</span></p><p data-lake-id="u7bcbd3ce" id="u7bcbd3ce"><span data-lake-id="u361714cf" id="u361714cf">&amp;#x9;b.同时把客户端的SYN报文，sn序列号+1作为ACK的报文内容传输给客户端。 &amp;#x9;</span></p><p data-lake-id="ud3c2776a" id="ud3c2776a"><span data-lake-id="ud17279b5" id="ud17279b5">&amp;#x9;c.服务端处于SYN</span><span data-lake-id="u14a68f3c" id="u14a68f3c">_</span><span data-lake-id="u862ea643" id="u862ea643">REVD状态</span></p><p data-lake-id="ubc9a2553" id="ubc9a2553"><span data-lake-id="u305ff386" id="u305ff386">3：第三次握手<br />&amp;#x9;a.客户端接收到SYN</span><span data-lake-id="ua13dd3f3" id="ua13dd3f3">_</span><span data-lake-id="ub4934b61" id="ub4934b61">ACK报文之后，把服务端SYN报文sn+1发送给服务端。<br />&amp;#x9;b.客户端处于establised,服务端接收后也处于establised状态。</span></p><p data-lake-id="u16c7bfd7" id="u16c7bfd7"><span data-lake-id="u30684303" id="u30684303">目的：为了确保客户端和服务端双方 接收和发送功能都是正常的。<br />第一次握手：客户端发送数据<br />此时什么结论都得不到<br />第二次握手：服务端接收到数据并发送数据给客户端<br />这时能得到结论，<br />服务端知道：客户端发送功能完好，服务端自己接收功能完好<br />客户端知道：依旧什么都不知道<br />第三次握手：客户端接受数据，并发送数据给服务端，服务端接收数据<br />客户端知道：我发送的那个数据服务端响应了，那么我自己的接收、发送功能都没问题。服务端既然能响应那说明他的接收发送功能也没问题。<br />服务端接收数据之后，服务端这边同样也确定了双方功能完好<br />至此三次握手结束。</span></p><h3 data-lake-id="aiHKN" id="aiHKN"><span data-lake-id="u6ff5c2b1" id="u6ff5c2b1">TCP四次挥手</span></h3><p data-lake-id="u6b2ea3ff" id="u6b2ea3ff"><span data-lake-id="u0d257caa" id="u0d257caa">流程图<br />文字描述：<br />0：首先，客户端和服务端双方都处于 establised状态<br />1：这时候，客户端准备关闭连接了，会发送一个 fin M 报文 给到服务端。<br />之后候客户端处于 fin_wait1状态<br />2：服务端接收到fin m 报文后，会把fin M + 1 然后通过ack报文发送给客户端。<br />之后服务端会处于close_wait状态。客户端收到后，会处于 fin_wait2状态<br />3：等服务端准备关闭时，会发送 fin N 报文给客户端。<br />之后服务端处于last_ack状态<br />4：客户端收到fin N 报文之后，会把fin N + 1 发送给服务端。<br />客户端状态会变成time_wait,一定时间内没有收到消息（2MSL，2个报文最大生存时间），代表服务端已经关闭，客户端也会变成close<br />服务端收到后状态变为，close</span></p>