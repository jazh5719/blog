### 分层

应用层：http

传输层：tcp  端对端

数据层：ip 点对点

链路层：网络接口

### tcp三次握手

[关于三次握手与四次挥手面试官想考我们什么？--- 不看后悔系列](https://juejin.cn/post/6844903834708344840)

&#x20;流程：&#x20;

流程的文字描述：&#x20;

0： 刚开始客户端处于closed，服务端处于listen&#x20;

1：一次握手 &#x9;

&#x9;a.客户端初始化他的序列号sn，通过报文SYN发给服务端。 &#x9;

&#x9;b.这时候客户端处于SYN\_send状态&#x20;

2：第二次握手 &#x9;

&#x9;a.服务端收到SYN报文之后，初始化他的序列号sn通过SYN发送给客户端。 &#x9;

&#x9;b.同时把客户端的SYN报文，sn序列号+1作为ACK的报文内容传输给客户端。 &#x9;

&#x9;c.服务端处于SYN\_REVD状态

3：第三次握手
&#x9;a.客户端接收到SYN\_ACK报文之后，把服务端SYN报文sn+1发送给服务端。
&#x9;b.客户端处于establised,服务端接收后也处于establised状态。

目的：为了确保客户端和服务端双方 接收和发送功能都是正常的。
第一次握手：客户端发送数据
此时什么结论都得不到
第二次握手：服务端接收到数据并发送数据给客户端
这时能得到结论，
服务端知道：客户端发送功能完好，服务端自己接收功能完好
客户端知道：依旧什么都不知道
第三次握手：客户端接受数据，并发送数据给服务端，服务端接收数据
客户端知道：我发送的那个数据服务端响应了，那么我自己的接收、发送功能都没问题。服务端既然能响应那说明他的接收发送功能也没问题。
服务端接收数据之后，服务端这边同样也确定了双方功能完好
至此三次握手结束。

### TCP四次挥手

流程图
文字描述：
0：首先，客户端和服务端双方都处于 establised状态
1：这时候，客户端准备关闭连接了，会发送一个 fin M 报文 给到服务端。
之后候客户端处于 fin\_wait1状态
2：服务端接收到fin m 报文后，会把fin M + 1 然后通过ack报文发送给客户端。
之后服务端会处于close\_wait状态。客户端收到后，会处于 fin\_wait2状态
3：等服务端准备关闭时，会发送 fin N 报文给客户端。
之后服务端处于last\_ack状态
4：客户端收到fin N 报文之后，会把fin N + 1 发送给服务端。
客户端状态会变成time\_wait,一定时间内没有收到消息（2MSL，2个报文最大生存时间），代表服务端已经关闭，客户端也会变成close
服务端收到后状态变为，close
