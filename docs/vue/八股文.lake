<!doctype lake><meta name="doc-version" content="1" /><meta name="viewport" content="adapt" /><h2 data-lake-id="aijzX" id="aijzX"><span data-lake-id="ufcb2a63d" id="ufcb2a63d">对vue的理解</span></h2><ul list="uced01eee"><li fid="u0f91a316" data-lake-id="ue8dc9d5b" id="ue8dc9d5b"><span data-lake-id="uf2393bdb" id="uf2393bdb">声明式框架。</span></li></ul><ol list="u8a9f438b" data-lake-indent="1"><li fid="uf3afe3af" data-lake-id="u0392196a" id="u0392196a"><span data-lake-id="ud7ae508e" id="ud7ae508e">就是我们先声明好数据和模板。当数据变更的时候会同步给视图进行更新。这种同步是vue帮我们做的。</span></li></ol><ul list="u87a36ed9"><li fid="ua9910592" data-lake-id="u8c0487f3" id="u8c0487f3"><span data-lake-id="u8eddc3b4" id="u8eddc3b4">借鉴了mvvm模式。</span></li></ul><ol list="u09998d5d" data-lake-indent="1"><li fid="u936b8b4e" data-lake-id="uf5f8a185" id="uf5f8a185"><span data-lake-id="u99e9f5b6" id="u99e9f5b6">在前端，mvvm是由mvc演化而来，因为mvc框架需要有一个控制器，里面会有大量的对dom的操作。所以mvvm是对控制器的简化。</span></li><li fid="u936b8b4e" data-lake-id="u4f816778" id="u4f816778"><span data-lake-id="u4d082817" id="u4d082817">响应式系统（0）</span></li></ol><ul list="u1699af7d"><li fid="u7cf4a45a" data-lake-id="u1e60aac0" id="u1e60aac0"><span data-lake-id="u29d550b8" id="u29d550b8">虚拟dom</span></li></ul><ol list="u75a5ea50" data-lake-indent="1"><li fid="u1b5cf0de" data-lake-id="u08cf6469" id="u08cf6469"><span data-lake-id="ue1824d59" id="ue1824d59">目的是为了减少对真实dom的操作。虚拟dom本质是一个js对象，其对应的加减操作要比真实dom性能（回流重绘）要好。因此，vue也是在对真实dom的操作中加了一层。最后只对真实dom进行一次更新。</span></li><li fid="u1b5cf0de" data-lake-id="ufafb17f1" id="ufafb17f1"><span data-lake-id="uec040134" id="uec040134">diff算法（0）</span></li></ol><ul list="u841bf68b" data-lake-indent="2"><li fid="ua77b1ee8" data-lake-id="ubaf1b7f8" id="ubaf1b7f8"><span data-lake-id="u0cbb92a7" id="u0cbb92a7">对比新老虚拟dom，获取最小量的dom操作</span></li><li fid="ua77b1ee8" data-lake-id="u12dde7b2" id="u12dde7b2"><span data-lake-id="u41a3879d" id="u41a3879d">只更这最小量的dom</span></li></ul><ol list="ubf6a928e" data-lake-indent="1"><li fid="u312935df" data-lake-id="ueec0af1d" id="ueec0af1d"><span data-lake-id="u749fe89d" id="u749fe89d">vdom是如何生成的</span></li></ol><ul list="ud2dea123" data-lake-indent="2"><li fid="u9d8be734" data-lake-id="u19bebc85" id="u19bebc85"><span data-lake-id="u040cf7c4" id="u040cf7c4">vue中组件有template模板</span></li><li fid="u9d8be734" data-lake-id="u55d00557" id="u55d00557"><span data-lake-id="ub25b9bff" id="ub25b9bff">编译时，编译器会把模板编译为rendder函数</span></li><li fid="u9d8be734" data-lake-id="uf78c31fb" id="uf78c31fb"><span data-lake-id="uc83bf7c7" id="uc83bf7c7">运行时，调用render函数返回虚拟dom</span></li><li fid="u9d8be734" data-lake-id="u62f9daef" id="u62f9daef"><span data-lake-id="u9e6da173" id="u9e6da173">后续patch把虚拟dom转换为真是dom</span></li></ul><ul list="ud2dea123"><li fid="u4523ffc3" data-lake-id="u7770dd3c" id="u7770dd3c"><span data-lake-id="u16bddaac" id="u16bddaac">编译时和运行时。</span></li></ul><ol list="ufb559a9e" data-lake-indent="1"><li fid="u13974922" data-lake-id="u3efedc0d" id="u3efedc0d"><span data-lake-id="u407dfb8a" id="u407dfb8a">模板语法，在编译时把模板语法编译成虚拟dom</span></li><li fid="u13974922" data-lake-id="uab55054a" id="uab55054a"><span data-lake-id="u972cc6e6" id="u972cc6e6">在运行时运行render函数将虚拟dom渲染为真实dom</span></li></ol><ul list="ucbae0abd"><li fid="ubf834db1" data-lake-id="ub298a59d" id="ub298a59d"><span data-lake-id="uc69037a5" id="uc69037a5">组件化</span></li></ul><ol list="u85983b40" data-lake-indent="1"><li fid="u02a1f98a" data-lake-id="u934105a9" id="u934105a9"><span data-lake-id="ub9c0310f" id="ub9c0310f">高复用，低耦合，提高开发效率</span></li><li fid="u02a1f98a" data-lake-id="u250ceaa4" id="u250ceaa4"><span data-lake-id="ue4cc4361" id="ue4cc4361">模板、属性、事件、插槽、钩子</span></li><li fid="u02a1f98a" data-lake-id="uaa262acc" id="uaa262acc"><span data-lake-id="u03f93e4a" id="u03f93e4a">每个组件都有一个渲染函数， watcher（vue2）、effect（vue3）</span></li></ol><p data-lake-id="ued20a4a5" id="ued20a4a5"><br></p><h2 data-lake-id="ZGRWV" id="ZGRWV"><span data-lake-id="u0e0e28d6" id="u0e0e28d6">对spa的理解</span></h2><ul list="ude0cd96d"><li fid="u843c3759" data-lake-id="u42db6d6e" id="u42db6d6e"><span data-lake-id="udc85a52d" id="udc85a52d">单页面应用。</span></li></ul><ol list="ua84e4d21" data-lake-indent="1"><li fid="u931e1230" data-lake-id="uf18dd2ed" id="uf18dd2ed"><span data-lake-id="uf25565ea" id="uf25565ea">本质是只有一个html文件，然后在html中有一个挂载点，浏览器执行main.js的时候会把存在js中的dom渲染出来，路由切换的时候，执行对应的js逻辑进行切换页面。</span></li><li fid="u931e1230" data-lake-id="ubfc6bfc7" id="ubfc6bfc7"><span data-lake-id="u6a7b8b5f" id="u6a7b8b5f">spa的缺点，1.无法进行seo优化。 2.首屏白屏时间比较长</span></li><li fid="u931e1230" data-lake-id="u5710d512" id="u5710d512"><span data-lake-id="uafa21585" id="uafa21585">spa的优点，1.加载完成之后打开其他页面时性能比较好。</span></li></ol><ul list="uebf27168"><li fid="u75221e28" data-lake-id="u17f4beb3" id="u17f4beb3"><span data-lake-id="u50dded14" id="u50dded14">路由。</span></li></ul><p data-lake-id="u21c1d83d" id="u21c1d83d"><br></p><h2 data-lake-id="Gm3c7" id="Gm3c7"><span data-lake-id="uf3cb8d59" id="uf3cb8d59">既然vue可以通过数据劫持精准探测数据变化，为什么还需要diff算法</span></h2><ol list="uae0ac589"><li fid="u965748c9" data-lake-id="u99cc6cf1" id="u99cc6cf1"><span data-lake-id="u4050b806" id="u4050b806">vue1.0是通过这样来实现的，如果一个属性对应一个watcher那么如果组件的数据过多会产生大量的watcher造成内存浪费，如果粒度过低，又会造成每个属性更改，整个组件全部更新的问题。所以采用组件级的watcher + diff算法来解决这两个问题。</span></li></ol><p data-lake-id="u7bc7c33b" id="u7bc7c33b"><br></p><h2 data-lake-id="tKbeG" id="tKbeG"><span data-lake-id="u29249d66" id="u29249d66">响应式数据流程</span></h2><ol list="u1ed6797e"><li fid="ua523fad8" data-lake-id="u84169cce" id="u84169cce"><span data-lake-id="u5f239167" id="u5f239167">definereactive和proxy的区别</span></li></ol><ul list="uf94726be"><li fid="u031f24a1" data-lake-id="u46a39a7b" id="u46a39a7b"><span data-lake-id="u9e4fc479" id="u9e4fc479">前者劫持属性，需要对监听对象遍历。proxy监听的是对象。</span></li><li fid="u031f24a1" data-lake-id="u765c2c83" id="u765c2c83"><span data-lake-id="uaa0a371b" id="uaa0a371b">前者如果新增属性，那么新增的属性也需要手动新增监听，后者不用（</span><card type="inline" name="math" value="data:%7B%22code%22%3A%22set%E3%80%81%22%2C%22id%22%3A%22JqC2A%22%7D"></card><span data-lake-id="uc6e01b99" id="uc6e01b99">delete）</span></li><li fid="u031f24a1" data-lake-id="ue0006896" id="ue0006896"><span data-lake-id="u8d96e1e1" id="u8d96e1e1">前者无法监听数组。所以vue对数组的push、pop、shift、unshift等进行了重写</span></li></ul><ol list="ud3981bf1"><li fid="u4f85c3b3" data-lake-id="ue7b97389" id="ue7b97389"><span data-lake-id="u42594b1f" id="u42594b1f">响应式流程</span></li></ol><p data-lake-id="u277f739e" id="u277f739e"><span data-lake-id="uaab6ac99" id="uaab6ac99"> 初始化时调用编译时产生的render函数，会走到响应式的getter方法内，进行依赖收集，把watcher收集到对应的dep数组内。</span></p><ol list="u46e9fdac" data-lake-indent="1"><li fid="u2f70326f" data-lake-id="u509ac4c2" id="u509ac4c2"><span data-lake-id="u332ae47d" id="u332ae47d">初始化时对数据进行数据劫持，vue2采用definereactive,vue3采用proxy。</span></li></ol><p data-lake-id="u9f7030ab" id="u9f7030ab"><br></p><h2 data-lake-id="ztqgr" id="ztqgr"><span data-lake-id="uf3f83b85" id="uf3f83b85">computed和watch</span></h2><ol list="u9ffba54f"><li fid="u87710834" data-lake-id="u5e5b049f" id="u5e5b049f"><span data-lake-id="u89400da2" id="u89400da2">computed，会维护一个dirty属性默认为true，第一次取值的时候会执行，把结果缓存dirty变成false，之后再取的时候会使用缓存不会重复执行computed</span></li><li fid="u87710834" data-lake-id="u2eaa99da" id="u2eaa99da"><span data-lake-id="u88184981" id="u88184981">如果computed依赖的值发生变化，会触发页面更新，dirty属性会变为true,取值同第一步操作</span></li><li fid="u87710834" data-lake-id="u0baef5c1" id="u0baef5c1"><span data-lake-id="u7a89d28b" id="u7a89d28b">computed 默认写的是一个get方法，vue会把这个方法作为一个data上的属性</span></li><li fid="u87710834" data-lake-id="u26255f11" id="u26255f11"><span data-lake-id="u7dd4e5d1" id="u7dd4e5d1">watch本身是一个变化的回调函数</span></li></ol><p data-lake-id="ubc14f5e4" id="ubc14f5e4"><br></p><h2 data-lake-id="hJcnE" id="hJcnE"><span data-lake-id="u43df1609" id="u43df1609">ref和reactive</span></h2><ol list="ud892b5f6"><li fid="u4322c32c" data-lake-id="u107bd70f" id="u107bd70f"><span data-lake-id="u19561dfd" id="u19561dfd">ref 是处理基本数据类型的响应式的。 vue3本身是用proxy进行代理的，无法对基本数据类型进行代理。</span></li><li fid="u4322c32c" data-lake-id="u418337ee" id="u418337ee"><span data-lake-id="u4d2f0f4d" id="u4d2f0f4d">ref 本质是使用 object.definpropty对对象的value属性进行了劫持。如果ref传的是个对象的话，会直接使用toReactive进行劫持把代理对象保存到value上</span></li></ol><p data-lake-id="ufc4d8931" id="ufc4d8931"><br></p><h2 data-lake-id="DMgTW" id="DMgTW"><span data-lake-id="ue32cb946" id="ue32cb946">watch和watchEffect</span></h2><ol list="uca5c492a"><li fid="u4d1af087" data-lake-id="uee835d03" id="uee835d03"><span data-lake-id="uce4a66f6" id="uce4a66f6">watchEffect的函数中所依赖的值变化了会执行一次回调函数</span></li><li fid="u4d1af087" data-lake-id="uc1612b43" id="uc1612b43"><span data-lake-id="uddc01de9" id="uddc01de9">watch的getter和回调函数是分开写的</span></li><li fid="u4d1af087" data-lake-id="u8505b029" id="u8505b029"><span data-lake-id="u814396bc" id="u814396bc">本质都是调用 reactiveEffect</span></li></ol><p data-lake-id="ub37e3b93" id="ub37e3b93"><br></p><h2 data-lake-id="nm1nC" id="nm1nC"><span data-lake-id="u2df37b74" id="u2df37b74">模板语法变为render函数</span></h2><ol list="u12ee3c37"><li fid="ub596a058" data-lake-id="u2b334bdd" id="u2b334bdd"><span data-lake-id="u719b50b4" id="u719b50b4">ast语法树 （tag，children等属性）</span></li><li fid="ub596a058" data-lake-id="uc67f7d0a" id="uc67f7d0a"><span data-lake-id="u5c4315fe" id="u5c4315fe">遍历语法树，字符串拼接的方式生成render函数，匹配属性、指令等</span></li></ol><p data-lake-id="u65396217" id="u65396217"><br></p><h2 data-lake-id="gSZRj" id="gSZRj"><span data-lake-id="ub09eecc3" id="ub09eecc3">v-for和v-if的优先级</span></h2><ol list="u6897a5f3"><li fid="ua9dea56a" data-lake-id="uc91f1ed9" id="uc91f1ed9"><span data-lake-id="u3e002eb1" id="u3e002eb1">都是不支持的语法</span></li><li fid="ua9dea56a" data-lake-id="u7bf0ec24" id="u7bf0ec24"><span data-lake-id="u6bf15acd" id="u6bf15acd">vue2中v-for的优先级高。vue2建议，先把数组filter筛选一下</span></li><li fid="ua9dea56a" data-lake-id="u001abca7" id="u001abca7"><span data-lake-id="ue1ce1130" id="ue1ce1130">vue3中v-if的优先级更高，写法类似于把v-if在外层用template包裹了一层</span></li></ol>