## 手写题

- [并发](../code/1.手写题/2.并发.js)
- 节流防抖深拷贝
```js
// 节流
function fun(callback, delay = 1000) {
    let timer = null
    return function (...args) {
        if (timer) return
        timer = setTimeout(() => {
            callback.apply(this, args)
            timer = null
        }, delay)
    }
}

// 防抖
function debounce(callback, delay = 1000) {
    let timer
    return function (...args) {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            callback.apply(this, args)
        }, delay)
    }
}


// 深拷贝
function deepClone(obj) {
    if (typeof obj !== 'object' || obj === null) return obj
    const ret = Array.isArray(obj) ? [] : {}

    for (let key in obj) {
        const val = obj[key]
        const type = Object.prototype.toString.call(val)
        if (type = '[object Date]') {
            ret[key] = new Date(val)
        } else if (type === '[object Symbol]') {
            ret[key] = Symbol.prototype.valueOf.call(val)
        } else if (type === '[object RegExp]') {
            ret[key] = new RegExp(val)
        } else {
            ret[key] = deepClone(val)
        }
    }

    return ret
}
```

- bfs、dfs
```js
const data = [{
    val: '0',
    children: [{
        val: '0-1',
        children: [{
            val: '0-1-2'
        }, {
            val: '0-1-3'
        }]
    }, {
        val: '0-2'
    }, {
        val: '0-3'
    }]
}]

// dfs
function dfs(list, ret = []) {

    for (let item of list) {
        const children = item.children || []
        ret.push(item.val)
        dfs(children, ret)
    }

    return ret
}

console.log(dfs(data, []))

// bfs
function bfs(list = []) {
    const ret = []
    const quque = list
    let node = quque.pop()
    while (node) {
        ret.push(node.val)
        const children = node.children || []
        for (let item of children) {
            quque.unshift(item)
        }
        node = quque.pop()
    }
    console.log(ret)
}
bfs(data)
```

## 八股文
- vue组合式api和选项式api怎么理解
    - 各自的原理
    - 使用的差异
    - 优缺点

## 自我介绍
您好，我是张昊杰，18年毕业在北京从事前端有5、6年时间了。
    工作经历从事toC的业务比较多，像h5、小程序、之前参与过跨端框架的建设，然后上一家公司是用Electron维护的一个桌面端应用，对electron和nodeJs也比较熟悉。
    因为做c端嘛，所以对用户体验和稳定性会比较关注，所以维护的项目都会去做一些优化的事情。


## 项目
- 性能优化
- 容器bv代替iframe
- 热更新

### 性能优化
- 背景：应用完全启动速度较慢，50分位置 5秒时间。
- 目的：加快开启速度，提高用户体验。
- 做法：利用nodeJs performance api mark标记点位，记录初始化时每一步骤的耗时。分析问题并解决

#### js依赖问题
问题：依赖引入的问题。electron本身是基于nodeJs的，然后我们项目是js文件内的头部通过import引入各种依赖（后续编译成require）。因为v8解析js是边解析，边执行的，这样的话项目小的时候还好，但是如果项目比较大引入的依赖比较多的时候解释执行引入的依赖就是会比较耗时。而且由于写法问题，把所有的依赖都放到头部，所以可能会有一些非初始化的依赖也在初始化的时候就执行了。
    
方法：针对这个问题，如果采用v8缓存的方案。改写require方法，第一次运行的时候会用nodeJS的VM模块执行这段js并且把他 编译过的字节码缓存下来放到特定的目录下。下次再次运行的时候运行到require时检测到当前版本有缓存会直接运行编译过的字节码。这也会省比较多的时间。大概500ms

#### 缓存h5
electron打开h5页面时走的网络请求，比较慢所以对这块进行了改造。
electron在打开一个h5html，html在解析js资源的时候会进行拦截使用本地文件。加快速度。

#### 流程问题
1.引入的crach包在mac上耗时较久的问题
2.判断是否在线的问题
3.启动页消失后，首页不展示的问题


## 容器化方案
- 背景：项目中对于第三方页面的承载都是使用的iframe。然后出现过一些问题。
1.崩溃问题：第三方页面的iframe崩溃的时候，整个应用崩掉了。而 某一个browserView的崩溃只是一个子进程的崩溃，不会引起主进程的崩溃，可以把他关掉。
2.iframe难以把控：因为第三方页面时嵌入在首页h5中的。iframe可以很容易操作首页的api，甚至是把首页给高丢失。browserView和iframe不同的是，每个iframe都有自己独立的webContents，原理上来说创建一个browserView相当于打开了一个tab。当前webContents内的相关操作是没有端的支持是无法操作其他browserView中的内容的，因此较为隔离
3.对于第三方页面使用端能力，也不方便，需要通过postmessage传递到首页，首页进行代理。如果iframe嵌套过多传递麻烦。

- 方案：
1.提供的方法，顶导的后退（关闭当前bv）、刷新(重新加载当前bv)，首页（关闭所有bv）
2.bv管理器，因为不存在切换bv，所以设计的bv表是由栈管理的，最后一个打开的肯定是首先要关闭的，当前的视口总是在栈的最后一个bv上。
3.设置统一的加载loading。



## 热更新
背景：只有阻断式更新， 强更新和弱更新。但这种是有问题的，比如有问题的版本不易修复。灰度放量的时候被灰度的用户可能会频繁更新，用户体验不好。
方案：采用基于electron  asar文件的静默更新模式。
1.打包时，会把业务代码用electron提供的asar打包方式打包产生一个文档包，并且把当前文档包和当前版本信息的json文件打包上传到平台上。
2.通过版本号来判断是否更新（后台），如果更新的话会把压缩包下载下来。解压，并且把当前的asar文件用新版本的替换，进行更新。

问题：
1.asar只能更新主代码块的逻辑，第三方或者其他使用dll层的代码不会被打包进去，所以无法更新。因为我们对dll的更新比较少，而且主要是解决更新频繁的问题
2.windows系统下有占用问题。在electron程序运行中，无法更新asar文件。因此会在关闭应用的时候，开启和主进程不关联的子进程，进行对asar的替换。
3.windows平台下会有写入权限的问题（非管理员权限在系统盘的某些目录无法写入）。




